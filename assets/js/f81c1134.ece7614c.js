"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"malware-analysis","metadata":{"permalink":"/blog/malware-analysis","source":"@site/blog/2025-04-07-malware-analysis/index.md","title":"Malware analysis - an introduction","description":"Malware analysis requires a structured approach to extract and understand hidden threats within various file formats and languages. By using the right tools, malware analysts can effectively deobfuscate, detect, and mitigate malicious payloads before they cause harm.","date":"2025-04-07T00:00:00.000Z","tags":[{"inline":true,"label":"security","permalink":"/blog/tags/security"},{"inline":true,"label":"malware-analysis","permalink":"/blog/tags/malware-analysis"}],"readingTime":15.685,"hasTruncateMarker":true,"authors":[{"name":"Luca Giorgino","title":"Me","url":"https://github.com/lucagiorgino","imageURL":"https://github.com/lucagiorgino.png","key":"luca","page":null}],"frontMatter":{"slug":"malware-analysis","title":"Malware analysis - an introduction","authors":"luca","tags":["security","malware-analysis"]},"unlisted":false,"nextItem":{"title":"Keystone Enclave","permalink":"/blog/keystone-enclave"}},"content":"Malware analysis requires a *structured approach* to extract and understand *hidden threats* within various file formats and languages. By using the right tools, malware analysts can effectively deobfuscate, detect, and mitigate *malicious payloads* before they cause harm.\\n\\n\x3c!--truncate--\x3e\\n\\nThe following are some notes from the Udemy (italian) course: [Introduzione alla malware analysis: Un approccio pratico](https://www.udemy.com/course/intro_malware_analisi/?referralCode=14E06E7C35D50C69D957). \\n\\n## Environment for malware analysis\\n[Malware](https://en.wikipedia.org/wiki/Malware) refers to any software program or code specifically designed to exploit, damage, disrupt, or gain unauthorized access to computer systems, networks, or data. Malware operates covertly, often without user consent.\\n\\nHere are some blog posts for further reading:\\n- The 12 Most Common Types of Malware: https://www.crowdstrike.com/en-us/cybersecurity-101/malware/types-of-malware/\\n- Malware Analysis Explained: https://www.crowdstrike.com/en-us/cybersecurity-101/malware/malware-analysis/\\n\\nA secure and controlled environment is crucial for effective malware analysis, often utilizing virtual machines, sandboxing tools, and forensic utilities to prevent system compromise and facilitate safe examination.\\n\\n### Host requirements\\n- Virtualization software like [Virtual Box](https://www.virtualbox.org/) with an installed operating system suited to the target malware under analysis,\\n- Windows 10 media creation tool: https://www.microsoft.com/it-it/software-download/windows10,\\n- When using a *shared folder* between the host and guest, always set it to **read-only** to prevent malware from writing files to the host system,\\n- Ensure to allocate an appropriate number of processor cores and memory, as some malware perform environment checks to detect virtualized environments and may terminate execution if the resources appear insufficient or unrealistic.\\n\\n:::warning\\nIn some situations, malware can exploit vulnerabilities in virtualization software, potentially escaping the virtual environment and compromising the host system.\\n:::\\n\\n### Guest requirements\\nInstall the operating system required for the malware analysis environment.\\n\\n**Common analysis tools**:\\n- Editor tool of your choice, example [Notepad++](https://notepad-plus-plus.org/downloads/),\\n- [Python](https://www.python.org/), high-level programming language,\\n- [7-zip](https://www.7-zip.org/), open source software for compression/decompression of various file formats,\\n- [CFF explorer](https://ntcore.com/explorer-suite/), binary editor - tool used to analyse and modify files in binary format,\\n- [System Informer](https://systeminformer.com/), tool that helps you monitor system resources, debug software and detect malware,\\n- [Detect it easy](https://github.com/horsicq/Detect-It-Easy), program for determining types of files,\\n- [Yara](https://github.com/VirusTotal/yara), used to identity malware,\\n- [Sysinternals](https://learn.microsoft.com/en-en/sysinternals/), set of utilities for troubleshooting and diagnosing Windows and Linux systems and applications,\\n- [Fiddler proxy](https://www.telerik.com/fiddler), HTTP/HTTPS system proxy, used to inspect network requests. To inspect traffic over TLS ensure to enable the correct setting. `Tools->Options->HTTPS`: Check `Decrypt HTTPs traffic`, Install certificate, Check \\"Ignore server certificate errors\\",\\n- [Wireshark](https://www.wireshark.org/), tool for inspecting network traffic across various protocols beyond just HTTP/HTTPS.\\n- (optional) [Windows Defender Remover](https://github.com/ionuttbara/windows-defender-remover), a tool which is uses to remove Windows Defender.\\n\\nIt is recommended to create virtual machine **snapshots** to easily restore the system to a clean state after each analysis, examples:\\n- `vanilla` - a clean, fresh OS installation\\n- `ready-to-play` - OS + analysis tools\\n \\n#### Windows - things to know\\n- [Windows Registry](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry): system-defined database in which applications and system components store and retrieve configuration data. It can be accessed using `WIN+R` and typing `regedit`:\\n  - administrator rights are required to modify the registry. Malware often targets `HKEY_CURRENT_USER`, `HKEY_USERS`, and `HKEY_LOCAL_MACHINE` keys,\\n  - malware leverages the registry for persistence, such as configuring automatic execution at start-up. For example, `HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunOnce` can be used to launch malware on boot (more information [here](https://attack.mitre.org/techniques/T1547/001/)).\\n  - each user has a unique identifier within the Windows Registry,\\n  - the Registry is a valuable resource in forensic analysis to assess system state and detect anomalies,\\n  - before executing malware, exporting Registry values can be useful for comparison after execution to identify changes made by the malware,\\n- when executed, malware typically follows an installation routine to avoid easy deletion from directories like \xa0`Downloads`. It often installs itself in the `AppData` folder (`%APPDATA%` - a Windows environment variable) \xa0to maintain persistence,\\n- Windows Shortcut (`.lnk`) are often used as an attack vector to run malicious code.\\n\\n:::tip\\nWhen analysing malware, *disable updates and Windows Defender*, then *add the user folder to the exclusion list* to prevent automatic detection and removal of the malware during the analysis process. Disable Hide settings and show extensions.\\n:::\\n\\n## Threat Hunting and Malware Triage\\n\\n**Threat Hunting** is a proactive cybersecurity process involving the systematic search for threats. More [here](https://www.crowdstrike.com/en-us/cybersecurity-101/threat-intelligence/threat-hunting/). \\n\\nBelow are some key resources commonly used by analysts:\\n- [MalwareBazaar](https://bazaar.abuse.ch/) is a platform for sharing and analysing malware samples. Malware files are typically *compressed and password-protected* to prevent accidental execution and reduce the risk of unintended infections,\\n- [Virus Total](https://www.virustotal.com/): is an *antivirus aggregator* that scans files and URLs using multiple security engines to detect threats. A *subscription is recommended* for advanced features like deeper analysis, historical data, and threat intelligence insights,\\n- [Hybrid Analysis](https://www.hybrid-analysis.com/): free malware analysis service for the community that detects and analyses unknown threats.\\n\\n**Phases of Malware Triage**\\n1. **Identify file type** - Determine the file format to understand how it operates and what tools are needed for analysis:\\n\\t- use [Detect it easy](https://github.com/horsicq/Detect-It-Easy): analyse the file and add extensions if applicable,\\n\\t- utilize [CFF explorer](https://ntcore.com/explorer-suite/): examine the file structure and metadata,\\n2. **Perform preliminary analysis** - Use analysis tools to gather initial insights into the file\u2019s behaviour and characteristics:\\n\\t- identify the hash: Compute the file hash and search in malware databases to determine if it is a known or new threat,\\n\\t- perform string analysis: Use `strings.exe` to extract readable text from the file,\\n\\t- search for filenames: if possible, identify the original filename and research it online for additional context,\\n\\t- use sandbox analysis: execute the file in a controlled environment to observe behaviour and extract further information, \\n3. **Identify the next steps (if necessary)**:\\n\\t- for example, identify configuration or Command and Control (C&C) Server.\\n  \\n## Analysing Malicious Files\\nAttackers frequently deliver malicious files through **spam emails** and other **attack vectors**. This section covers methods for analysing different file types commonly used in malware distribution.\\n\\n### `.xls` files\\nMicrosoft Excel files (`.xls`, `.xlsm`) can contain **macros**, which attackers use to execute malicious code.\\nAttackers can easily embed macros in malicious documents using the following methods:\\n- *Right-click Menu* \u2192 _Assign Macro..._\\n- *View* \u2192 _Macros_ \u2192 _View Macros_\\n- *Worksheet Tab** \u2192 _Insert_ (to add macros)\\n- *Worksheet Tab* \u2192 _View Code_ (opens Microsoft Visual Basic for Applications - VBA)\\n\\nAttackers often protect macro access with passwords, making direct extraction difficult. Alternative methods are required to extract and analyse embedded macros.\\n\\n#### Extracting Macros with `oletools`\\n\\n[oletools](http://www.decalage.info/python/oletools)\xa0is a Python toolkit for analysing\xa0[Microsoft OLE2 files](http://en.wikipedia.org/wiki/Compound_File_Binary_Format) (used in legacy Office formats like `.doc`, `.xls`, `.ppt`). Install it with:\\n\\n```bash\\npip install oletools\\n```\\n\\nKey `oletools` Commands:\\n- `olemeta <filename>` - extracts (standard) metadata, useful for threat hunting and identifying similar malicious samples,\\n- `oleid <filename>` - detect specific characteristics usually found in malicious files, such as macros,\\n- `olevba <filename>` - extracts macro source code for analysis.\\n\\n#### Analysing Extracted Macros\\nMalware macros are often **obfuscated** to hide their true functionality. For example, during the analysis look for:\\n- obfuscated strings hiding URLs or commands,\\n- download-and-execute functions, such as: `rundll32.exe URL,Function`.\\n\\n:::note\\nSince 2023, Microsoft **blocks automatic macro execution** for files downloaded from the web, reducing but not eliminating the threat.\\n:::\\n\\n### `.pdf` files\\n[PDFs are structured documents](https://medium.com/@jberkenbilt/the-structure-of-a-pdf-file-6f08114a58f6) that can contain hidden malicious code. While they can be analyzed with a text editor, reading them directly is often challenging due to compression and encoding mechanisms. [`peepdf-3`](https://github.com/digitalsleuth/peepdf-3) is a powerful Python tool designed to simplify PDF analysis, allowing analysts to extract JavaScript code, embedded objects, and suspicious URLs efficiently.\\n\\nInstall it with:\\n```bash\\npip install peepdf-3\\n```\\n\\n#### Basic Commands\\nOpen a PDF in interactive mode: `peepdf -i <filename>`. Look for **suspicious objects and streams**, as they may contain embedded JavaScript/JS objects or external URLs (e.g., phishing links or download sites)\\n\\nUse interactive mode:\\n```bash\\n> help # list the possible commands\\n> object <object_number>\\n```\\n\\nAttackers may use **URL obfuscation** to make a malicious domain look legitimate:\\n- `scheme://[user:password@]host[:port]/path[?query][#fragment]`,\\n- example: `https://docs.google.comformasda....@maliousdomain.com/`\\n\\nAn analyst may believe that the link leads to Google Docs, but it actually redirects to a malicious site that initiates the **malware execution chain**.\\n\\n### `.iso`, `.img`, `.lnk`\\n- `.iso` / `.img` files are used as containers for additional malicious files (`.dll`). Users may not notice `.dll` file presence if they have `Show hidden files, folders, and drives` option disabled.\\n- `.lnk` shortcut files to execute malware: check the file properties \u2192 `Target` to identify the command being executed. For example, `C:\\\\Windows\\\\system32\\\\rundll32.exe malicious.dll, malicious_fun`\\n \\n### `.dll` (Dynamic Link Library) Files\\nAttackers can hijack a legitimate DLL ([DLL Hijacking](https://www.okta.com/identity-101/dll-hijacking/)), injecting malicious functions while retaining original functionality. DLL files expose functions through the **export table**, making it possible to identify added malicious functions. You can use [CFF explorer](https://ntcore.com/explorer-suite/) to start analysing a DLL file.\\n\\n### `.msi` (Microsoft Installer) Files\\n`.msi` files can be misused to install malware. Attackers often embed `.dll` payloads inside `.msi` packages. \\n\\nInstall [`Orca.exe`](https://learn.microsoft.com/en-us/windows/win32/msi/orca-exe) via **Windows SDK Installer** (select \\"MSI Tools\\" during installation). Localize `Orca-x86_en-us.msi` and install it. To analyse an `.msi` file with` Orca.exe`, simply drag and drop the file into the application.\\n\\nInspect tables such as:\\n- **File Table** \u2192 Lists all embedded files (e.g., `.dll`, `.exe`),\\n- **CustomAction Table** \u2192 may reveals execution commands (e.g., launching `rundll32.exe malicious.dll, malicious_fun`).\\n\\nYou can also extract files from `.msi` using 7-Zip. You can also find `.cab` files inside `.msi` packages and can be used as hidden containers for malicious payloads.\\n\\n## Script-based Malware\\n**Multi-Stage Unpacking** - Malware often executes in **stages**, requiring step-by-step unpacking to reveal the final payload.\\n### PowerShell \\nPowerShell (`.ps1` scripts) is a powerful scripting language commonly used in the early stages of malware attacks for automation, system reconnaissance, and payload execution.\\n\\nBy default, PowerShell restricts script execution from third-party sources. To enable it, use: `Set-ExecutionPolicy RemoteSigned`. \\n\\nPossible tools for analysis:\\n- **Visual Studio Code + PowerShell Extension**: ideal for debugging and script analysis,\\n- **PowerShell ISE**: a built-in tool for script execution and debugging.\\n\\n:::tip\\n(*Optional*) Depending on the malware under analysis: **disabling network access in the virtual machine** can help prevent accidental internet requests, unauthorized data exfiltration, or command-and-control communication.\\n:::\\n\\nMalicious PowerShell scripts often use [Windows API](https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) - functions like:\\n```\\nDllImport(\\"kernel32.dll\\")\\nVirtualAlloc(...)\\n```\\n\\nScripts may execute other threads or process. You can use [System Informer](https://systeminformer.com/) to inspect active processes, read and dump process memory for further analysis.\\nFor example, you can load memory dumps into a binary analysis tool like [CFF explorer](https://ntcore.com/explorer-suite/), which includes a \\"Quick Disassembler\\" for low-level inspection.\\n\\nPowerShell-based malware is often heavily obfuscated, using techniques such variable and function renaming, reversing or encoding strings. To improve readability, deobfuscation is recommended. Since doing this manually can be tedious and time-consuming, consider using deobfuscation tools or writing a simple script to automate the process.\\n\\n### JavaScript, JScript and VBScript\\n\\nJavaScript usually runs within a sandboxed browser environment and does not have direct system privileges, unless browser vulnerabilities are exploited. On Windows, [Windows Script Host](https://staff.cdms.westernsydney.edu.au/~jianhua/SAP_300165/tutorials/Practical_3_files/WSHCh01.pdf) provides an environment in which users can execute scripts in various languages that use various object models to perform tasks. \\n\\nA JavaScript malware can be debugged using: **Visual Studio + Windows Script Host**. \\nIn Visual Studio settings you can set the debugger: `cscript.exe //X $(ItemPath)`\\n\\nUseful websites:\\n- [JavaScript Obfuscator](https://obfuscator.io/),\\n- [JavaScript Deobfuscator](https://deobfuscate.io/).\\n\\nVBScript is a deprecated programming language for scripting on Microsoft Windows using Component Object Model, based on classic Visual Basic and Active Scripting. ([Wiki](https://en.wikipedia.org/wiki/VBScript), [`ActiveXObject`](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/automat/activex-objects)).\\n\\n\\n`.hta` files executed via the `mshta.exe` utility, can often used as script containers for malware. Learn more: [Red Canary - mshta Attack Technique](https://redcanary.com/threat-detection-report/techniques/mshta/). \\n\\n## Portable Executable (PE) Format\\n\\nPortable Executable (PE) format\xa0is a file format for executables used in Windows operating systems, it\u2019s based on the\xa0COFF\xa0file format (Common Object File Format). A PE file is a data structure that holds information necessary for the OS loader to be able to load that executable into memory and execute it. PE file extensions include `.exe`, `.dll`, `.scr`, and `.sys`. More details [here](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format) in the Microsoft documentation.\\n\\nWhen analysing PE binaries, consider the differences between *managed and unmanaged languages*, *little endian vs big endian* when interpreting hex data, and *memory mapping*, as file offsets and in-memory addresses often differ. [System Informer](https://systeminformer.com/) can be used to analyse memory.\\n\\nSome articles for further reading:\\n- [The Process of Compilation in C++, Java and .Net](https://developingthefuture.net/compilation-process-and-jit-compiler/),\\n- [Difference between \\"managed\\" and \\"unmanaged\\"](https://stackoverflow.com/questions/3563870/difference-between-managed-and-unmanaged),\\n- [Understanding Big and Little Endian Byte Order](https://www.digital-detective.net/understanding-big-and-little-endian-byte-order/),\\n- [Memory Management](https://learn.microsoft.com/en-us/windows/win32/memory/memory-management) (Microsoft doc),\\n- Wikipedia: [Address space](https://en.wikipedia.org/wiki/Address_space), [Virtual memory](https://en.wikipedia.org/wiki/Virtual_memory), [Virtual address space](https://en.wikipedia.org/wiki/Virtual_address_space).\\n\\nBelow are the main sections commonly found in the PE format:\\n- `DOS Header`\\n\\t- `e_magic`: signature **MZ** (indicates a valid DOS executable),\\n\\t- `e_lfanew`: offset where the **NT Header** starts,\\n- `NT Header`\\n\\t- `File Header`, contains general information about the PE file, including the target architecture,\\n\\t- `Optional Header` (despite the name, it\u2019s required for executables):\\n\\t    - `Magic`: Identifies whether the file is 32-bit (`0x10B`) or 64-bit (`0x20B`),\\n\\t    - `AddressOfEntryPoint`: Entry point for execution (where execution starts),\\n\\t    - `ImageBase`: Preferred memory address where the file should be loaded,\\n\\t    - `DllCharacteristics`: If ASLR is enabled, the DLL can be relocated in memory, impacting malware analysis,\\n\\t    - **Data Directories**: pointers to key structures such as the **Import Table, Export Table, and Resource Table**,\\n- Section Headers\\n\\t- `.text`: contains executable code,\\n\\t- `.rdata`,`.data`: store read-only and writable data, such as strings and variables,\\n- `Import Directory`: lists DLLs and functions the executable depends on. Example:\\n\\t- `kernel32.dll`: common Windows API functions,\\n\\t- `IsDebuggerPresent`: often used by malware to detect if it\u2019s running in a debugging environment.\\n\\n:::tip\\nIn [CFF explorer](https://ntcore.com/explorer-suite/) , go to the Optional Header section, then click on \\tthe\xa0`DllCharacteristics`\xa0row, `DLL can move`\u2192 enable/disable ASLR option.\\n:::\\n\\n### .NET\\nMachine code disassembly cannot process a managed language compiled executable because it is not native machine code. Instead, it must be disassembled from the intermediate language using an appropriate disassembler. Managed files are easier to decompile because they contain additional metadata, such as symbol names, class structures, and method definitions.\\n\\n- [dnSpyEx](https://github.com/dnSpyEx/dnSpy) is a debugger and .NET assembly editor. Go to entry point and start analyse it,\\n- [de4dot](https://github.com/de4dot/de4dot) is a .NET deobfuscator and unpacker written in C#. Here the compiled binaries: [de4dot-built-binaries](https://github.com/vee2xx/de4dot-built-binaries),\\n- `ildasm.exe` - is an intermediate language disassembler, [docs](https://learn.microsoft.com/en-us/dotnet/framework/tools/ildasm-exe-il-disassembler). Usage examples:\\n\\t- `ildasm file.exe /out:file.il`\\n\\t- `ilasm file.il /out:file_m.exe`\\n\\nWhile inspecting .NET code, look for some of the following instructions: \\n```\\n# Can be used to load second-stage payloads in memory \\nAssembly.Load( ... )\\n# function from kernel32.dll\\n# allocate memory with execution rights\\nVirtualAlloc(...) \\n```\\n\\n[System Informer](https://systeminformer.com/) has a .NET Assemblies tab, which can be used to inspect loaded .NET assemblies within a process. This feature allows to detect suspicious or injected .NET assemblies, which may indicate malware activity.\\n\\n[shed (.NET Runtime Inspector)](https://github.com/enkomio/shed), dnSpyEx, or [System Informer](https://systeminformer.com/) can be used to analyse .NET processes and extract loaded binaries.\\n\\n### Unmanaged code\\n*Requirements*: knowledge of [Assembly language](https://en.wikipedia.org/wiki/Assembly_language), how stack and heap works, [Windows calling convention](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention)\\n\\n- [x64dbg](https://x64dbg.com/) open-source x64/x32 debugger for windows, \\n\\t- To emulate what a malware does we can load `rundll32.exe` and pass the DLL under analysis to the command  (Option \u2192 Settings \u2192 User DLL Load),\\n- [PE-sieve](https://github.com/hasherezade/pe-sieve)is a tool that helps to detect malware running on the system, as well as to collect the potentially malicious material for further analysis. Recognizes and dumps variety of implants within the scanned process: replaced/injected PEs, shellcodes, hooks, and other in-memory patches,\\n- [Ghidra](https://ghidra-sre.org/) is a software reverse engineering (SRE) framework,\\n- Other alternatives: [IDA Pro](https://hex-rays.com/ida-pro), [Binary Ninja](https://binary.ninja/), [radare2](https://rada.re/), [iced-rs](https://github.com/icedland/iced).\\n \\n## YARA rules\\n[YARA](https://virustotal.github.io/yara/) is a powerful tool designed primarily for malware researchers to **identify and classify malware samples**. It allows users to create *rules* that describe malware families (or any other artifacts) using *textual or binary patterns*. Each rule consists of a *set of strings* and a *boolean expression* that defines its detection logic.\\n\\nSuggestions for crafting an effective YARA rule:\\n- identify meaningful strings or format strings within the malware, \\n- look for imported libraries and function names that indicate malicious behaviour,\\n- consider obfuscation techniques, malware may encode or manipulate critical strings to evade detection.\\n\\nBeware of false positives and false negatives when creating YARA rules. While false positives can lead to unnecessary alerts, false negatives are more dangerous, as they allow malware to go undetected. Test YARA rules extensively. Examples of YARA rules can be found on the [documentation](https://yara.readthedocs.io/en/latest/).\\n\\nRunning YARA from the command-line\\n```bash\\nyara64 <rule file> <binary to analyse> | <PID>\\n```\\n\\n[UNPACME](https://www.unpac.me/) is an automated malware unpacking service and it can be used for YARA development, testing, and hunting.\\n\\n## Malware Analysis Report\\nMalware analysis reports provide critical insights into a threat, serving as the key output of the analysis process. A report should help assess impact and understand the threat.\\n\\nA well-structured report combines strategic and technical details, covering the malware\u2019s nature, operators, targets, and in-depth analysis of its functions, payloads, and behaviours.\\n\\nExamples of malware reports:\\n- [Reports and IoCs from the NCSC malware analysis team](https://www.ncsc.gov.uk/section/keep-up-to-date/malware-analysis-reports),\\n- [ANY.RUN](https://any.run/malware-reports/) malicious database - provides free access to many public reports,\\n- [The DFIR Report](https://thedfirreport.com/),\\n- WikiLoader: https://www.proofpoint.com/us/blog/threat-insight/out-sandbox-wikiloader-digs-sophisticated-evasion.\\n \\n## Vocabulary, Tips and Resources\\n\\n- A\xa0**malware sandbox**\xa0is a virtual environment used to isolate and analyse the behaviour of potentially malicious software. It execute a file and trace all the operations that are performed,\\n- [**Indicators of Compromise** (IOCs)](https://www.cloudflare.com/learning/security/what-are-indicators-of-compromise/) are evidence left behind by an attacker or malware that can be used to identify a security incident. Common examples include file hashes, IP addresses, domain names, or registry changes. They are often included in analysis reports to support detection and response efforts;\\n- [**Command and Control (C&C) Server**](https://sysdig.com/learn-cloud-native/what-is-a-command-and-control-server/) is a server controlled by an attacker to is used to deliver malware, issue commands, exfiltrate data, or coordinate further attacks on targeted systems,\\n- **Packer**: utility used to compress and obfuscate files, making them more difficult to analyse. Malware often leverages packers to evade detection by antivirus software,\\n- **AsyncRAT** is a Remote Access Tool (RAT) designed to remotely monitor and control other computers through a secure encrypted connection,\\n- **Quackbot** is a famous banking trojan, more [here](https://www.darktrace.com/cyber-ai-glossary/qakbot),\\n- **Autostart Extension Points (ASEP)** are commonly used by malware as [persistence mechanisms](https://www.infosecinstitute.com/resources/malware-analysis/common-malware-persistence-mechanisms/) and define a starting point for the malware,\\n- [Sysinternals](https://learn.microsoft.com/en-en/sysinternals/):\\n  - `Autoruns64.exe`, useful to list and reports auto-start services and many other things,\\n  - `string.exe` usage example: `string.exe -n 20 file.exe`, list all string of 20 character in the executable,\\n- [ret42/RE-Thing](https://github.com/ret42/RE-Thing) - list of reverse eng. tools,\\n- ired.team notes: [miscellaneous-reversing-forensics](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals),\\n- [reverse-engineering-cheat-sheets](https://cyberlab.pacific.edu/resources/reverse-engineering-cheat-sheets/analyzing-malicious-document-files.pdf).\\n \\n\\n#### Software Obfuscation Techniques\\nAttackers use **obfuscation techniques** to evade detection and analysis. Common transformations include:\\n- **String Encoding** \u2013 Hiding commands, URLs, and payloads.\\n- **Control Flow Flattening** \u2013 Making code execution paths difficult to follow.\\n- **Packing and Encryption** \u2013 Wrapping malicious code inside additional layers to avoid detection. \\n\\nFor a detailed breakdown of obfuscation methods, refer to:  \\n[Tigress - Software Obfuscation Transformations](https://tigress.wtf/transformations.html)\\n\\n#### ATT&CK Matrix\\n[MITRE ATT&CK](https://attack.mitre.org/) is a globally-accessible knowledge base of adversary tactics and techniques based on real-world observations."},{"id":"keystone-enclave","metadata":{"permalink":"/blog/keystone-enclave","source":"@site/blog/2024-02-15-keystone-enclave/index.md","title":"Keystone Enclave","description":"This post outlines the functionalities of the Keystone Enclave framework, extracted from my master\'s thesis (updated to December 2022). Keystone is an open-source framework designed for building Trusted Execution Environments, adaptable for various platforms that are based on RISC-V hardware.","date":"2024-02-15T00:00:00.000Z","tags":[{"inline":true,"label":"trusted-computing","permalink":"/blog/tags/trusted-computing"}],"readingTime":14.63,"hasTruncateMarker":true,"authors":[{"name":"Luca Giorgino","title":"Me","url":"https://github.com/lucagiorgino","imageURL":"https://github.com/lucagiorgino.png","key":"luca","page":null}],"frontMatter":{"slug":"keystone-enclave","title":"Keystone Enclave","authors":"luca","tags":["trusted-computing"]},"unlisted":false,"prevItem":{"title":"Malware analysis - an introduction","permalink":"/blog/malware-analysis"},"nextItem":{"title":"What I learnt using Actix-web","permalink":"/blog/what-i-learnt-using-actix-web"}},"content":"This post outlines the functionalities of the [Keystone Enclave](https://keystone-enclave.org/) framework, extracted from my master\'s thesis *(updated to December 2022)*. Keystone is an open-source framework designed for building Trusted Execution Environments, adaptable for various platforms that are based on RISC-V hardware.\\n\\n\x3c!--truncate--\x3e\\n\\n## Trusted Execution Environment\\nA **Trusted Execution Environment (TEE)** is an execution environment that runs alongside but is isolated from the device\'s main operating system.\\nIt ensures that the *confidentiality* and *integrity* of the code and data loaded in the TEE are preserved. \\nTrusted applications running on TEE have access to the full capabilities of a device\'s main processor and memory, while hardware isolation shields these components from user-installed apps running in the main operating system. The various included trusted applications are protected from one another by software and cryptographic isolations within the TEE.\\\\\\nThe two most common TEE implementations at the moment are ARM TrustZone and Intel SGX. All these TEEs make design decisions based on either the target applications or threat models and these choices are fixed since they are strictly hardware related. They were not designed to have flexibility or extensibility for enclave developers. If the hardware changes or has a new feature, the enclave developer has to redesign the TEE.\\nAll TEE platforms aim to reduce the enclave\'s trusted computing base, and they have managed to achieve different degrees of success. The [Trusted Computing Base (TCB)](https://apps.dtic.mil/sti/pdfs/ADA108831.pdf) is a section of the system, which could include hardware, firmware and software. It is responsible for enforcing the security policy of the system. Additionally, closed-source hardware and microcode implementations make it impossible for a third party to evaluate the security of TEEs.\\n\\n### Customizable Trusted Execution Environment\\n[Customizable TEE](https://keystone-enclave.org/2019/07/22/Keystone-Paper.html) is the solution to closed-source hardware-implemented TEEs problems. It has been designed to be flexible, and configurable and to have a small TCB. It has been designed with clear abstractions and a modular programming model which simplifies for others to extend and add features to the TEE. An example of a customizable TEE is Keystone. Three logical actors, such as the manufacturer (who makes the hardware), the platform provider (runs the hardware, such as a cloud provider), and the enclave developer (who writes software that runs in the enclaves), were identified by Keystone developers as being a part of the customizable TEE ecosystem. In a customizable TEE, as opposed to a standard TEE, decisions made by all 3 actors together determine the security guarantees offered and the functionalities enabled.\\\\\\nKeystone offers security primitives that can be joined together via the software framework rather than creating a single instance of TEE hardware. The TEE can be modified by the creator of the enclave and the platform provider to suit their threat models or platform configurations. The Keystone project offers a general and formally proven interface for a variety of devices to create an open standard for TEEs. \\n\\n## RISC-V Background\\n[RISC-V](https://riscv.org/technical/specifications/) is open-source, which provides Keystone with several benefits. The most noticeable is that anyone can see how it works, understand the threat model it can operate under, and verify how exploits/patches function.\\\\\\nOther advantages of RISC-V are security-oriented primitives, which provide efficient isolation, the most notable being [Physical Memory Protection (PMP)](https://sifive.github.io/freedom-metal-docs/devguide/pmps.html). RISC-V is an evolving and community-driven Instruction Set Architecture (ISA). Keystone has been designed and developed using RISC-V standard security features. Moreover, the ever-growing world of RISC-V gives Keystone a wide variety of potential platforms and different deployment scenarios to which it can adapt to. \\n\\n### RISC-V Privilieged ISA\\n[RISC-V](https://riscv.org/technical/specifications/) has three software privilege levels (in increasing order of capability): user mode (U-mode), supervisor mode (S-mode), and machine mode (M-mode). Only one of the privilege modes can be active on the processor at once.\\\\\\nThe active privilege level determines what the software can do while it is running. These are typical applications for each level of privilege:\\n- *U-mode*: user processes \\n- *S-mode*: kernel (including kernel modules and device drivers) or hypervisor\\n- *M-mode*: bootloader and firmware.\\n\\nWhen the processor is in the highest privilege mode, M-mode, it is in control of all physical resources and interrupts. As with microcode in Complex Instruction Set Computer (CISC) ISAs (such as x86), M-mode is not interruptible and not affected by the interference of lower modes. M-mode is used in Keystone for executing the TCB of the system, the *security monitor* (SM).\\n\\n![keystone-vs-x86](./TEE-keystone-vs-x86.svg) *Architecture differences between x86 and Keystone*\\n\\nThe following are some advantages of utilizing an M-mode software as the TCB:\\n- programmability: unlike microcode for x86, in RISC-V M-mode software can be written using pre-existing toolchains and programming languages, such as C \\n- agile patching: since the TCB is purely software, bugs or vulnerabilities can be patched without updates, which are specific to a particular hardware \\n- verifiability: compared to hardware, the software is generally simpler to be formally verified.\\n\\n### Physical Memory Protection\\n[Physical Memory Protection (PMP)](https://sifive.github.io/freedom-metal-docs/devguide/pmps.html) is a strong standard primitive that enables M-mode to control the access to physical memory from lower privileges modes. Keystone requires PMP to implement memory isolation of enclaves.\\nOnly software in M-mode can configure the PMP, which is controlled by a series of control and status registers (CSR) that limit physical memory access to the U-mode and S-mode. Depending on the platform design, PMP entries number can change. \\n\\n![pmp-img](./pmp-reg.svg) *Image representing PMP registers*\\n\\nSince PMP exclusively works on physical addresses, S-mode can continue to support virtual addresses without affecting the security of the system. Even though each processor may implement PMP differently in hardware, the basic guarantees are part of the standard. PMP is used by Keystone Security Monitor to create memory isolation.\\n\\n\\n## Keystone components\\nA Keystone-capable system is made up of different modules operating in various privilege modes as shown in the figure below:\\n\\n![keystoneComponents](./keystone-components.png) _Keystone system with host processes, untrusted OS, security monitor, and multiple enclaves (each with runtime and eapp)_\\n\\n#### Trusted Hardware\\nTrusted Hardware is a CPU package built by an honest manufacturer that must enclose standard RISC-V cores, which are Keystone compatible, and a root of trust. Optional features of the hardware could also include memory encryption, cache partitioning, a cryptographically safe source of randomness, etc. Platform-specific plug-ins are needed by the Security Monitor to support optional features.\\n\\n### Security Monitor\\n**Security Monitor (SM)** is a trusted software that runs in M-mode and works as the small TCB in the Keystone system. Before the SM can be considered trusted, it must be verified by the hardware root of trust. Then, the root of trust *measures* the SM, generates a keypair for remote attestation, signs the public key, and eventually can continue booting. The measurement of the SM consists in computing the hash of the SM firmware image. The SM manages isolation boundaries between the enclaves and the untrusted OS, therefore it implements the majority of Keystone\'s security guarantees.  It serves as an interface for managing the enclave\'s lifecycle and utilising platform-specific features. The OS and enclaves may call SM functions using the Supervisor Binary Interface (SBI). Specifically, the SM provides the following functionality:\\n- *memory isolation* using RISC-V PMP\\n- *remote attestation* (signatures and measurement): the goal is to demonstrate to a remote client that the enclave contains the expected application, and is running on trusted hardware\\n- and other features, such as system PMP synchronization, enclave thread management and side-channel defences\\n\\n### Runtime\\nKeystone developers implemented the **Runtime (RT)** with the goal of minimal and flexible TCB. It is an S-mode software. As a result, enclave applications can use modular system-level abstraction (e.g., virtual memory management). It provides kernel-like functionality, such as system calls, trap handling, virtual memory management and so on. Although the RT functions similarly to a kernel inside an enclave, most kernel functionalities are not necessary for the enclave application. To allow enclave developers to include only the necessary functionality and minimize the TCB, Keystone developers created an example of RT called Eyrie. It enables reusability since it is compatible with multiple-user programs. And by adding RT modules, they expand RT functionality without changing user applications or without complicating the SM.\\n\\n![runtime-example](./runtime.svg) _Example of runtime reusability on the left and its functionalities on the right_\\n\\n### Enclave\\nAn **Enclave** is an environment isolated from the untrusted OS and other enclaves. Each enclave is provided with a private physical memory region which is accessible by only the enclave and SM. Each enclave consists of a user-level enclave application called *eapp* and a supervisor-level runtime. An eapp is a user-level application that executes in the enclave. A developer can create a custom eapp from scratch, or just execute an existing RISC-V binary in Keystone. The enclave lifecycle is shown below. \\n\\n![enclave-lifecycle](./Enclave%20lifecycle.png) _Enclave Lifecycle from Keystone docs_\\n\\nThe main phases are:\\n- *creation*: when an enclave is started it has a contiguous range of physical memory that is called Enclave Private Memory (EPM). In the beginning, the EPM is allocated by the untrusted host, which initialises it with the enclave\'s page table, the runtime and the enclave application. When the untrusted host calls the SM to create an enclave, the SM isolates and secures the EPM using a PMP entry, and then the PMP status is propagated throughout all of the system\'s cores. Subsequently, before the enclave execution, the enclave\'s initial state is measured and verified by the SM.\\n- *execution*: the SM enters the enclave on one of the cores as soon as the untrusted asks for it. The PMP permission is enabled to the core by the SM, and the core starts running the eapp. The RT can exit or re-enter the enclave at any time depending on the execution flow of the eapp. The PMP permissions are switched to keep the isolation each time a core exits or enters the enclave.\\n- *destruction*: the untrusted host may want to destroy the enclave at any moment, when it happens, the EPM is cleared by the SM and the PMP entry is freed. The untrusted host then definitely reclaims the released memory.\\n\\n\\n### Edge Calls\\nFunction calls that enter or exit the enclave are known as *edge calls* in Keystone, as in other enclave systems. For instance, if an enclave wants to send a network packet, it must use an edge call to deliver the data to an untrusted host process. The current version of Keystone allows *enclave* $\\\\rightarrow$ *untrusted host* calls, also known internally as *ocalls* (outbound calls, names under discussion). In the current version of Keystone, all ocall wrapping code uses shared memory regions to transfer data. When referencing data in these regions virtual address pointers are never used, instead, only offsets into the region are used.\\n \\n![ocall-lifecycle](./ocall.svg) _Simplified example of an ocall lifecycle_\\n\\n#### Edge Calls Lifecycle\\nConsider for example a generic `ocall_do_something`, as represented in Fig. [ocall-lifecycle]. This call transfers some values passed as arguments from the enclave to be processed by the host process (it could be a value to be printed, a file to be stored and so on). The enclave application calls `ocall_do_something(...)`, which is an edge wrapper function.\\\\\\n`ocall_do_something(...)` uses the system-call-like interface to the runtime to execute an *ocalls* similar to `ocall(OCALL_DO_SOMETHING, &input, sizeof(input), &ouput,  sizeof(output))`. The enclave passes a pointer to the value, the size of the argument and any necessary return buffer information. \\nAfter allocating an `edge_call` structure in the shared memory region, the runtime fills out the call type, copies the value into another part of the shared memory, and sets up the offset to the argument value. Note that, in Keystone, edge calls employ offset values in the shared memory area, rather than pointers.\\nThe runtime subsequently exits the enclave with an `SBI_CALL`, i.e. `sbi_stop_enclave()`, passing a value indicating that the enclave is executing an *ocalls* rather than shutting down. \\n\\nAfter resuming execution of the Keystone kernel driver, it checks the enclave\'s exit status, notes a pending *ocalls* and handles control to the userspace host process. \\nThe registered *ocalls* handler wrapper for `OCALL_DO_SOMETHING` is dispatched by the userspace host process, which also consumes the edge call. The wrapper generates a pointer to the argument value from the offset in the shared memory region and then calls `do_something` with the value as an argument. The host wrapper determines whether any return values must be copied into the shared memory region upon return and returns the control to the driver after setting the edge call return status to `SUCCESS`. \\n\\nThrough an `SBI_CALL`, the driver rejoins the enclave runtime. The enclave *ocalls* wrapper code is resumed once the runtime determines whether any return information has to be copied from the shared region into return buffers. Finally, the enclave function that has called at the beginning `ocall_do_something` receives any return values from the *ocalls* wrapper code.\\n\\n\\n## Memory isolation using RISC-V PMP\\nIn Keystone, developers refer to the memory section that an enclave uses as a *region* and each region is defined by a PMP entry. The SM employs two PMP registers for internal purposes (i.e. security monitor memory and untrusted memory). One active enclave may use one of the remaining PMP entries each. RISC-V PMP has several properties, the most relevant are: \\n- prioritization by index: the index of PMP entries statically determines the priority. Indices go from `0` to `N`, where `N` depends upon the platform. `0` is the highest priority, whereas `N` is the lowest \\n- default denies: if no PMP entry matches with an address, the memory access will be rejected by default.\\n\\nFor simplicity, in the following explanation PMP entries are denoted as `pmp[i]` where `i` is an index. Below is a representation of the memory in its initial state. At the start of the boot process, physical memory is not accessible by U- or S-modes. \\n\\n``` title=\\" Memory state when booting start \\\\label{sm-pmp-1}\\"\\n-: inaccessible (NO_PERM), =: accessible (ALL_PERM)\\n\\npmp[1:N]    |                                       | : undefined\\nnet result  |---------------------------------------|   \\n```\\n\\nThe SM sets the highest priority PMP entry to cover the address range containing itself and sets all permission bits to 0. Suddenly, the SM sets the lowest priority PMP entry to cover the full memory and sets all permission bits to 1, this will allow the OS to access the remaining memory and start booting. The result can be seen below.\\n\\n``` title=\\"Memory state just after booting\\"\\n-: inaccessible (NO_PERM), =: accessible (ALL_PERM)\\n\\npmp[0]       |-------|                              | : SM memory\\npmp[others]  |                                      | : undefined\\npmp[N]       |======================================| : OS memory\\nnet result   |-------|==============================|\\n```\\n\\nAs shown below, every time the SM creates an enclave, it will select a PMP entry for the enclave to defend its memory from other U-/S-mode software.\\n\\n``` title=\\"Memory accessible by the untrusted host\\"\\n-: inaccessible (NO_PERM), =: accessible (ALL_PERM)\\n\\npmp[0]       |-------|                              | : SM memory\\npmp[1]       |              |---------|             | : enclave \\n                                                        memory\\npmp[others]  |                                      | : undefined\\npmp[N]       |======================================| : OS memory\\nnet result   |-------|======|---------|=============|\\n```\\n\\nWhen the SM enters the enclave and executes the eapp, it flips the permission bits of the enclave\'s PMP entry and the last PMP entry. Untrusted shared buffer is the term for the contiguous memory region that Keystone enables the OS to allocate in the OS memory space in order to use it as an enclave\'s communication buffer. This is shown below.\\\\\\nThe SM just flips the permission bits back when it leaves the enclave. When an enclave is destroyed by the SM, the PMP entry is made available for usage by other enclaves.\\n\\n``` title=\\"Memory accessible by a running enclave\\"\\n-: inaccessible (NO_PERM), =: accessible (ALL_PERM)\\n\\npmp[0]       |-------|                              | : SM memory\\npmp[1]       |              |=========|             | : enclave \\n                                                        memory\\npmp[others]  |                                      | : undefined\\npmp[N]       |                                |==|  | : untrusted \\n                                                        shared \\n                                                        buffer\\nnet result   |-------|------|=========|-------|==|--|\\n```\\n\\n## Keystone key-hierarchy\\nBelow is shown the key hierarchy of Keystone. The root of the key hierarchy is the asymmetric processor key pair (`SK_D` and  `PK_D`). The asymmetric security monitor key pair (`SK_SK` and `PK_SM`) is derived from the measurement of the security monitor (`H_SM`) and the private processor key (`SK_D`).\\nAs a result, the computed security monitor key pair is bound to the processor and to the identity of the security monitor itself.\\n\\n![keystone-key-hierarchy](./Keystone%20key%20hierarchy.svg) _The key hierarchy of Keystone_\\n\\n### Sealing-Key Derivation\\nThe image above also illustrates how *sealing-keys* are derived. An enclave can generate a key for data encryption using the data-sealing capability, enabling it to store data in untrusted non-volatile memory outside the enclave. This key is tied to the identity of the processor, the security monitor, and the enclave. As a result, only the same enclave using the same processor and security monitor can generate the same key. Data can be encrypted using this key and stored in unsecured, non-volatile memory. After an enclave restart, it can generate the same key once more, retrieve the encrypted data from the untrusted storage, and then use the derived key to decrypt it. A sealing key is computed starting from three inputs:\\n- the private security monitor key (`SK_SM`)\\n- the hash of the enclave (`H_SM`)\\n- a key identifier\\nThe key identifier is an extra input for the key derivation function selectable by the enclave. A single enclave can generate several keys by giving the key identifier various values.\\n\\n## Resources\\n\\n- [Trusted Execution Environment: What It is, and What It is Not](https://doi.org/10.1109/Trustcom.2015.357), Sabt, Mohamed and Achemlal, Mohammed and Bouabdallah, Abdelmadjid\\n- [Introduction to Trusted Execution Environment: ARM\'s TrustZone](https://blog.quarkslab.com/introduction-to-trusted-execution-environment-arms-trustzone.html)\\n- [Specification of a trusted computing base (TCB)](https://apps.dtic.mil/sti/pdfs/ADA108831.pdf)\\n- [Keystone blog](https://keystone-enclave.org/blog/)\\n- [Keystone Enclave\'s documentation](https://docs.keystone-enclave.org/en/latest/index.html)\\n- [Keystone: An open framework for architecting trusted execution environments](https://doi.org/10.1145/3342195.3387532), Lee, Dayeol and Kohlbrenner, David and Shinde, Shweta and Asanovi\'c, Krste and Song, Dawn\\n- [Physical Memory Protection](https://sifive.github.io/freedom-metal-docs/devguide/pmps.html)\\n- [RISC-V Specification Documentations](https://riscv.org/technical/specifications/)"},{"id":"what-i-learnt-using-actix-web","metadata":{"permalink":"/blog/what-i-learnt-using-actix-web","source":"@site/blog/2024-02-12-what-i-learnt-using-actix-web/index.md","title":"What I learnt using Actix-web","description":"In this post, I\u2019ll share my few key learnings from using Actix Web.","date":"2024-02-12T00:00:00.000Z","tags":[{"inline":true,"label":"rust","permalink":"/blog/tags/rust"},{"inline":true,"label":"actix-web","permalink":"/blog/tags/actix-web"}],"readingTime":1.67,"hasTruncateMarker":true,"authors":[{"name":"Luca Giorgino","title":"Me","url":"https://github.com/lucagiorgino","imageURL":"https://github.com/lucagiorgino.png","key":"luca","page":null}],"frontMatter":{"slug":"what-i-learnt-using-actix-web","title":"What I learnt using Actix-web","authors":"luca","tags":["rust","actix-web"]},"unlisted":false,"prevItem":{"title":"Keystone Enclave","permalink":"/blog/keystone-enclave"},"nextItem":{"title":"How I structure my React applications","permalink":"/blog/how-i-structure-my-react-applications"}},"content":"In this post, I\u2019ll share my few key learnings from using Actix Web.\\n\\n\x3c!--truncate--\x3e\\n\\n## Project structure\\n\\nThis is how I structured the backend when working with Actix Web.\\n\\n```shell\\nserver/\\n\u251c\u2500\u2500 src/\\n\u2502\xa0\xa0 \u251c\u2500\u2500 dtos/\\n\u2502\xa0\xa0 \u251c\u2500\u2500 controllers/\\n\u2502   \u251c\u2500\u2500 middlewares/\\n\u2502\xa0\xa0 \u251c\u2500\u2500 repository/\\n\u2502\xa0\xa0 \u251c\u2500\u2500 utils/      \\n\u2502\xa0\xa0 \u251c\u2500\u2500 errors.rs\\n\u2502\xa0\xa0 \u251c\u2500\u2500 lib.rs\\n\u2502\xa0\xa0 \u2514\u2500\u2500 main.rs\\n\u251c\u2500\u2500 .env\\n\u2514\u2500\u2500 Cargo.toml\\n```\\n\\n\\n## Error management\\n\\nFor error handling, I found the `thiserror` crate particularly useful due to its powerful `derive` macro, which simplifies custom error definitions. Then, implementing the `ResponseError` trait enables mapping `ServerError` to an `HttpResponse`, which includes the appropriate status code and a JSON response containing the error message. Example is shown below.\\n\\n```rust\\nuse actix_web::{HttpResponse, ResponseError, http::header::ContentType};\\nuse reqwest::StatusCode;\\nuse serde_json::json;\\n\\n#[derive(thiserror::Error, Debug)]\\npub enum ServerError {\\n\\n    // Other errors ...\\n\\n    // Database Errors\\n    #[error(\\"Row not found\\")]   \\n    RowNotFound,\\n    #[error(\\"tokio_postgres error\\")]\\n    TokioPostgresError(#[from] tokio_postgres::error::Error),\\n    #[error(\\"Middleware error: {0}\\")]\\n    MiddlewareError(String),\\n}   \\n\\nimpl ResponseError for ServerError {\\n\\n    fn error_response(&self) -> HttpResponse {\\n        HttpResponse::build(self.status_code())\\n            .insert_header(ContentType::html())\\n            .json(json!({\\n                \\"error\\": self.to_string()\\n            }))\\n    }\\n\\n    fn status_code(&self) -> StatusCode {\\n        match *self {\\n            // Other errors ...\\n            ServerError::RowNotFound => StatusCode::NOT_FOUND,\\n            ServerError::TokioPostgresError(_) => StatusCode::INTERNAL_SERVER_ERROR,\\n            ServerError::MiddlewareError(_) => StatusCode::INTERNAL_SERVER_ERROR,\\n        }\\n    }\\n}\\n```\\n\\n## Middlewares\\n\\nIn one project, I worked on developing a middleware responsible for extracting a JWT from a request and performing custom verification. At the time, I found the documentation on creating and using [Actix middleware](https://actix.rs/docs/middleware/) somewhat unclear ([docs.rs](https://docs.rs/actix-web/latest/actix_web/middleware/)). My goal was to define a single request that would be preprocessed by the custom middleware. To achieve this, I simply needed to use the `wrap` macro.\\n\\n```rust\\nuse actix_web::{body::MessageBody, dev::{ServiceRequest, ServiceResponse}, Error, HttpMessage};\\nuse actix_web_lab::middleware::Next;\\n\\npub async fn middleware_foo(\\n    req: ServiceRequest,\\n    next: Next<impl MessageBody>,\\n) -> Result<ServiceResponse<impl MessageBody>, Error> {\\n    // pre-processing\\n\\n    req.extensions_mut().insert( SomeData{ /*...*/ });\\n\\n    // invoke the wrapped middleware or service\\n    let res = next.call(req).await?;\\n\\n    // post-processing\\n    Ok(res)\\n}\\n```\\n\\n```rust\\n#[get(\\"/example-request\\", wrap = \\"from_fn(middleware_foo)\\")]\\nasync fn example_request(\\n    req: HttpRequest,\\n    opt_some_data: Option<ReqData<SomeData>>,\\n) -> Result<HttpResponse, ServerError> {\\n    \\n    let some_data = opt_some_data.ok_or(ServerError::MiddlewareError(\\"Missing strucuture\\".to_string()))?.into_inner();\\n    \\n    // use some_data\\n\\n    Ok( /*...*/ )\\n}\\n```"},{"id":"how-i-structure-my-react-applications","metadata":{"permalink":"/blog/how-i-structure-my-react-applications","source":"@site/blog/2024-02-10-how-i-structure-my-react-applications/index.md","title":"How I structure my React applications","description":"Since university, I always used React for all of my front-end projects.  This is how I usually structure them:","date":"2024-02-10T00:00:00.000Z","tags":[{"inline":true,"label":"web-applications","permalink":"/blog/tags/web-applications"},{"inline":true,"label":"react","permalink":"/blog/tags/react"}],"readingTime":0.83,"hasTruncateMarker":true,"authors":[{"name":"Luca Giorgino","title":"Me","url":"https://github.com/lucagiorgino","imageURL":"https://github.com/lucagiorgino.png","key":"luca","page":null}],"frontMatter":{"slug":"how-i-structure-my-react-applications","title":"How I structure my React applications","authors":"luca","tags":["web-applications","react"]},"unlisted":false,"prevItem":{"title":"What I learnt using Actix-web","permalink":"/blog/what-i-learnt-using-actix-web"}},"content":"Since university, I always used [React](https://react.dev/) for all of my front-end projects. \x3c!--truncate--\x3e This is how I usually structure them:\\n\\n\x3c!--truncate--\x3e\\n\\n```shell\\nfrontend/\\n\u251c\u2500\u2500 public/ # Static directory. Any contents inside here will be copied into the root of the final build directory. As an example images and `wasm` libraries\\n\u251c\u2500\u2500 src/\\n\u2502\xa0\xa0 \u251c\u2500\u2500 api/ # API call to backend components\\n\u2502\xa0\xa0 \u251c\u2500\u2500 components/ # Shared components implemented for application-wide use\\n\u2502\xa0\xa0 \u251c\u2500\u2500 hooks/ # Shared hooks implemented for application-wide use\\n\u2502   \u251c\u2500\u2500 pages/ # Application pages/routes\\n\u2502\xa0\xa0 \u251c\u2500\u2500 types/ # Shared types utilized throughout the entire application\\n\u2502\xa0\xa0 \u251c\u2500\u2500 utils/ # Shared utility functions\\n\u2502\xa0\xa0 \u251c\u2500\u2500 index.css # Main application component\\n\u2502\xa0\xa0 \u251c\u2500\u2500 main.tsx  # Main application component\\n\u2502\xa0\xa0 \u2514\u2500\u2500 vite-env.d.ts # vite file for TypeScript IntelliSense\\n\u251c\u2500\u2500 .env # Env Variables\\n\u251c\u2500\u2500 .eslintignore # eslint file\\n\u251c\u2500\u2500 .eslintrc.cjs # eslint file\\n\u251c\u2500\u2500 .gitignore\\n\u251c\u2500\u2500 LICENSE\\n\u251c\u2500\u2500 README.md\\n\u251c\u2500\u2500 index.html \\n\u251c\u2500\u2500 package.json\\n\u251c\u2500\u2500 package-lock.json\\n\u251c\u2500\u2500 tsconfig.json\\n\u251c\u2500\u2500 tsconfig.node.json\\n\u2514\u2500\u2500 vite.config.ts # vite config file\\n```"}]}}')}}]);